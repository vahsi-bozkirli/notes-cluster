Kafka
http://www.emrebozlak.com/kafka-terminolojisi-ve-mimarisi/
Broker: Kafka kümesinde çalışan her bir sunucu veya servise broker denir. Brokerlar fiziksel olarak kurulu oldukları sunucuya bağlıdırlar.
ama bir broker kendi üstünde olmasa bile kümede ki tüm topic ve partitionlardan haberdardır. brokerlar hem producer hemde consumer lar için bağlantı noktası olarak görev alırlar. brokerların her biri eşsiz bir sayı ile temsil edilir(101,102,vb...)
Broker discovery/bootstrap server consumer veya producer lar sadece bir broker üzerindeki bootstrap servisine bağlanarak tüm kümede bulunan diğer brokerlar topicler ve partitionların durumunu ve bağlantı noktalarını öğrenebilirler, bu bilgileri bootstrap server metadata olarak istemcilere sunmaktadır 
Topic: Verilerin yazıldığı yaratıldığı anda tüm brokerlar tarafından erişilebilir olan kafkanın veri tabanları veya MQ larda bulunan kuyruklara benzeyen yapısıdır, topicler istenen kadar oluşturulabilir
Partition: verilerin yazıldığı her brokerın kendisine özel olan ve bir topiğe bağlı fiziksel disk üzerindeki alanı temsil eder bir topiğe ait birden fazla partition olabilir, her partitionun 20 mb/s okuma hızı vardır 
partitiona yazılan veri bir kez yazılır belli bir süre boyunca saklanır ve saklanan veri silinemez, topic yazılırken kaç partition oluşturulacağını belirtebiliriz, kafka broker sayısına göre partitionları küme içerisinde dağıtır bu konudaki iyi uygulamalardan biri broker sayısı veya onun katı kadar partition oluşturulması yönündedir
replikasyon: brokerlardan biri zarar görürse veri kaybını önlemek için partition replikasyonu sağlanır
offset: offsetler partition özelinde olup veriler her partitiona yazıldığında bir identity number atanır bu sayede veriler hem partitiona yazıldığı sırayla okunur hemde consumerlar bir partitionda okuma yaparken hangi mesajda kaldıklarını hatırlayabilirler
offset sayısı 0 dan başlar
Offset’ler partition özelinde olduğundan dolayı bir topic’e sahip tüm partition’ların offset sayıları farkılır sadece bir partition’nın leader ve onun replica’ları aynı offset’e sahiptir.
Producer: Kafka terminolojisine göre mesaj(log) yaratan ve ilgili topic’e yazan uygulama/sistemlere verilen isimdir. Producer’lar bootstrap server sayesinde tüm broker, topic ve partition’ların listesine erişebilirler bu sayede mesajı nereye yazacağını ve nasıl yükü dağıtacağını kendisi karar verebilir
Producer’lar her mesajı yazarken yazılım işleminden sonra onay(ACK) talep edebilirler. Kafka şu anda 3 tip ACK desteklemektedir, bunlar;
ACK = 0; yani mesajı yazdıktan sonra cevap beklememesi, bunun handikabı veriyi producer’ı broker’a bıraktıktan sonra bir aksilik olur ve yazamazsa producer bundan haberdar olmayacak ve veri kaybına sebep olabilir.
ACK = 1; Producer leader partition’a mesaj yazıldığında ACK cevabını alır. Veri kaybı riski görece olarak düşük olsa da leader’in ISR partitionlara kopyalaması bitmeden ACK verildiği için eğer tam bu esnada leader partition bulunduğu broker devre dışı kalırsa veri kaybı olabilir.
ACK = all; Producer hem leader hem de tüm ISR’e yazma işlemi bitmeden ACK cevabını almaz bu sebepten dolayı veri kaybı riski en düşük olan model ama Producer tarafı için cevabı beklemesi gerektiğinden performansı en düşük olan seçenektir.
Message Key: Uygulamaların(Producer) Kafka’ya yazdığı mesajlar 3 parçadan oluşmaktadır; zaman damgası, mesajın içeriği ve message key. Message key her mesaj için ayrı oluşturur ve aynı key’e sahip mesajlar aynı partition’lara yazılırlar. Bunu Producer eğer belirtmezse, kafka kendisi her mesaj için yaratıp kendisi bir partition’a atayabilir veya alternatif olarak belli tip bir mesajın aynı partition’a yazılmasını istiyorsak özelliklede okuma sırasının her zaman doğru olmasını bekliyorsak message key’i elle de atayabiliriz.
Consumer: Kafka’dan verileri okuyan sistemlere verilen isimdir, aynı producer’lar gibi bootstrap serverüzerinden tüm Kafka kümesine erişebilir ve kendi load balance’ını yapma yetisine sahiptir. Consumer’lar partitionlardan verileri sırayla okur, burada dikkat edilmesi gereken nokta Kafka’ya mesajlar yazılırken birden fazla partition’a yazıldığından dolayı Consumer’lar aynı sırayla partitionlara erişmediklerinden dolayı Kafka’ya yazılma sırasından farklı olarak okunabilir. Mesajlar sadece partition’lar içerisinde sıralıdır, partition’lar bir birinden farklı sırada okunabilir.
Consumer Group: Aynı Topic’i okuyan birden fazla consumer’ın olması durumunda aynı mesajın tekrar tekrar okunmasının önüne geçmek için Consumer Group kullanılır. Consumer group içerisinde bulunan tüm consumer’lar en az bir partition’a atılır ve aynı grup içerisindeki diğer consumer aynı partitiona atanmaz. Böylelikle tekrarlı okumaların önüne geçilir.
Consumer Group içerisinde hangi consumer’ın hangi partition’la eşleştiğini, gruba yeni consumer geldiğinde veya çıktığında partition’ların tekrar dağıtılması işlemini Consumer coordinatör denilen, Kafka’nın broker’larından birini bu rol için leader seçtiği bir node üzerinde olur.
Consumer Group kullanımıyla ilgili iyi uygulamalardan biri de Consumer sayısının asla Partition sayısını geçmemesidir. Consumer group her bir partition’ı sadece bir consumer’a atayacağından dolayı fazla consumerlar boşta kalacaktır.
__consumer_offset isimli topic’den bahsetmem gerekir. Bu topic kafka tarafından yaratılan ve yönetilen bir topictir ve consumer’lar bir partition’dan her okuma yaptıklarında hangi offset’te kaldıklarını burada tutuluyor. Consumer group’a yeni bir üye katıldığında veya bir consumer kesinti yaşayıp tekrar kafka’ya bağlandığında buradan nerede kaldığını hatırlayarak devam ediyor. Kafka kümesini ilk kurduğunuzda __consumer_offset’in mutlaka minimum 3 node’a replice edilmesini ayarlamanız gerekmektedir, aksi durumda __consumer_offset’in leader partition’larını tutan broker’ı kaybetmeniz durumunda servisiniz duracaktır.
Consumer delivery semantics: Consumer’ın ne zaman offset’i commit ettiğini belirler.
At most once: Offset consumer tarafından okunur okunmaz commit edilir, eğer consumer tarafında mesaj okunduktan sonra işlemlerde sorun oluşursa veri kaybı oluşabilir
At least once: Offset’in commit edilmesi consumer okuduğu mesajı işledikten sonra yapılır, veri kaybı riski az olmasına rağmen mesaj birden fazla kere okunabilir.
Exactly once: Daha çok Kafka’dan kafka’ya mirrormaker gibi süreçlerde kullanılır.

Zookeeper; özellikle büyük veri projeleri başta olmak üzere birçok açık kaynak projesinde kullanılan, dağıtık, key-value veri saklama yeteneğine sahip açık kaynaklı bir servistir. Zookeeper kafka için aşağıdaki rolleri üstlenir;
Kafka kümesinin takibi; Zookeeper kümede bulunan tüm broker’ları heartbeat servisleriyle izler ve bir tanesine erişilememe durumunda broker listesinden çıkartır. Böylelikle bootstrap servisi üzerinden producer ve consumer’lar bu broker’ı göremezler. Aynı şekilde yeni bir broker’ın eklmesi durumunda tüm kümeye bildirimini yapar.
Controller seçimi: Kafka broker’larından biri kümedeki tüm partitionların leader/follower ilişkini controller yönetir. Bir broker devre dışı kaldığında onun üzerindeki leader partitionlara sahip hangi replicaların leader olacağını seçer. Bu role sahip broker’ın cevap verememe durumunda Zookeeper yeni bir controller seçer
Topic konfigürasyonlarının ve ACLs’lerin tutulması: Kümede hangi topic’ler, kaç adet partitiona sahip, partition durumları, replicationların durumu ve yerlerinin bulunduğu metadataları tutar ve yönetir. Aynı zamanda kullanıcıların broker’lar ve topic’ler üzerindeki yetkileride burada tutulmaktadır.
Kotalar: Topic’ler ve partitionlar ile kullanıcıların yazma/okuma kota bilgilerini burada tutar.
Zookeeper Kafka’dan ayrı bir servistir ve ayrı olarak konumlandırılması ve planlanması gerekmektedir. Zookeeper leader follower mekanizmasıyla çalışmaktadır, yani zookeeper kümesindeki bir sistem tüm işlemleri, değişiklikleri ve koordinasyonu üstleniyor diğer nodelarsa onu takip ediyorlar. Kümede lider seçimi çoğunluk oyuna göre yapılmaktadır, bu sebepten dolayı Zookeeper kümesinin node sayısının 1,3,5,7… gibi tek sayılardan oluşması gerekmektedir.
Wed Feb 23 2022 17:00:18 GMT+0300 (GMT+03:00)